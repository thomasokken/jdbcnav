In Javascript, Table.addRow() hangs when called on a table with 0 rows.

I made a few changes to PROFICIENCY_FACTS_AGG using a bit of JavaScript;
changed 4 cells each in 10 rows. Then tried to commit, and it took several
minutes with 100% CPU load. Why? This should be linear in the number of edits
made, no? Table size should not be relevant.
UPDATE: is this a Heisenbug? I.e., is the simple act of looking at a table
cell sufficient to change it? The slowness suggests that *all* rows were
being updated.

Support Oracle SEQUENCE.

When selecting the "References" pop-up menu option to follow a foreign 
key back to the corresponding row in the referenced table, the actual 
row is no longer highlighted. UPDATE: I could not reproduce this later on, but
it does raise more concerns about the possibility that the background load
thread is making Swing calls it shouldn't be making (maybe even the events
fired by the TableModel should be initiated from an invokeLater?).

When the table in the Table Details window is re-sorted, the row 
selection is not updated.

* Why does the UI freeze while waiting for a connection to open?
  Did I screw up the ConnectThread logic somewhere?
* Why the screwy behavior while opening huge windows? Am I messing up the Swing
  state by making AWT calls from the BackgroundLoadThread? (Hint:
  SwingUtilities.invokeLater(); maybe my model notifications are unsafe.)
* Support swapping tables to files, so you can start loading ridiculously huge
  data sets without having to supply impossibly large -Xmx parameters.
* When generating a populate script, am I still doing linear searches to find
  matching rows, or am I actually doing something clever like sorting both
  tables according to their PK, and then using an O(n1+n2) algorithm?

In addition to generating scripts, there should also be an option to 
execute them right away, with the additional option to run them without 
transactions. The idea being to be able to copy or update databases 
without ever having to store the generated sql.

CSV Import/Export: pluggable filters to support tab-delimited, customizable CSV
options (change separator, quotation conventions, etc.), different
representations for null values (zero-length string, the word NULL, some other
special notation).

The PK values used by the 'Select FK Value' command are cached inside the
BasicTable object (in the pkValues member), but there's currently no provision
for invalidating that cache when the table is modified.
The conservative approach would be to run a query *each time* getPKValues() is
invoked.

Cascaded delete/update: when the user deletes or changes a PK, offer to
propagate those changes to related tables.

When MemoryMonitor notices that memory is getting low, in addition to showing a
warning dialog, it should also pause in-progress table loads. Without this, the
low-memory warning may be useless, because a table loading thread may overflow
memory before the user even has time to react to the low-memory warning.
(For now, at least MemoryMonitor could be useful for diagnosing whether certain
problems (flaky table loads?) are due to memory shortages or not).

Revisit BLOB/BINARY handling: does it work correctly with MySQL and Transbase?
Also, revisit the BIT (bit array) type in PostgreSQL. Would be nice if that
were handled in a manner compatible with Transbase's BITS/BITS2 types.

When opening multiple table editing windows at the same time, and one or more
of them are for tables containing Oracle LONG or LONG RAW columns, the
exception "Stream has already been closed" may occur, or the application may
freeze completely. To avoid this, you must always open tables containing LONG
or LONG RAW columns separately. It would be nice if JDBC Navigator would load
such tables separately automagically; this will require (1) a new Table
property mustBeLoadedSeparately, plus (2) code in BasicDatabase and
JDBCDatabase to load such tables serially (the easiest approach would be to
load them first, before opening all the remaining windows; this will require
a mechanism whereby the Database can keep track of whether any loads are still
in progress). Of course this also affects other tables that might be opened
while a background load of a LONG-containing table is in progress; the solution
will probably have to be something along the lines of a queue.

"Set Password" should make the user type the password twice if it doesn't match
any of the existing ones (i.e., if it does not successfully decrypt any
encrypted connection configs) -- because that means it's a new password, and
there's otherwise the danger that the user could accidentally encrypt all his
connection configs using a mistyped password.

Hourglass cursor for slow operations that block the UI. Maybe also use Windows-
style "hourglass+arrow" cursor for QueryResultFrame while query is in progress.

Progress dialog for Generate Script.

Make "Reload Tree", "Clear Cache", and "Remove Orphans" scriptable, so that
you can mix the SQL embedding and the JDBCNav functionality in one script --
this could be useful for testing etc.

TypeSpec should distinguish between LONG and LOB types; also, it should
maintain a 'size' property for such types. These changes are mostly relevant
for accurate cross-DB SQL script generation, but the 'size' property could also
be used to enforce the constraint when editing cells (this should probably also
be done for the number and string renderers and editors).

Visual schema editor.

Graphical query generator and plan optimizer.
